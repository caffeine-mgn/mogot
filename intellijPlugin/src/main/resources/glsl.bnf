{
  parserClass="pw.binom.glsl.GLSLParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="GLSL"
  psiImplClassSuffix="Impl"
  psiPackage="pw.binom.glsl.psi"
  psiImplPackage="pw.binom.glsl.psi.impl"

  elementTypeHolderClass="pw.binom.glsl.psi.GLSLTypes"
  elementTypeClass="pw.binom.glsl.psi.GLSLElementType"
  tokenTypeClass="pw.binom.glsl.psi.GLSLTokenType"
}

simpleFile ::= item_*

private item_ ::= (DERECTIVE|number1|STRUCT_DEFINITION|GLOBAL_VAR_DEFINITION|FUNCTION_DEFINITION|COMMENT_LINE|COMMENT_BLOCK|CRLF)

property ::= (KEY SEPARATOR VALUE)
private END_LINE
private SPACE
private ASSIGN
private OP_PLUS
private OP_MINUS
private OP_TIMES
private OP_DIV
DERECTIVE


private ASSIGN_PLUS
private ASSIGN_MINUS
private ASSIGN_TIMES
private ASSIGN_DIV

private OP_LT
private OP_GT
private OP_LE
private OP_GE
private LEFT_PARENTHESIS
private RIGHT_PARENTHESIS
private COMMA
private NOT
FOR
UNARY_PLUS
UNARY_MINUS
LEFT_INDEX
RIGHT_INDEX
DOT
UNIFORM

ASSIGN_OP ::= (ASSIGN_PLUS | ASSIGN_MINUS | ASSIGN_TIMES | ASSIGN_DIV)
PRIMITIVE ::= VEC3 | VEC4 | INT | FLOAT
CONVER_PRIMITIVE ::= VEC3 | VEC4
private number1 ::= (NUMBER)
VAR_DEFINITION_EXP ::= ((PRIMITIVE | ID) ID)
STRUCT_DEFINITION ::= (STRUCT) (ID) (LEFT_BRACE) ( VAR_DEFINITION_EXP GLOBAL_ARRAY_DEF END_LINE )* (RIGHT_BRACE) END_LINE
GLOBAL_ARRAY_DEF ::= (LEFT_INDEX NUMBER? RIGHT_INDEX)? (LEFT_INDEX NUMBER RIGHT_INDEX)*
GLOBAL_VAR_DEFINITION ::= (IN | OUT | UNIFORM) VAR_DEFINITION_EXP GLOBAL_ARRAY_DEF END_LINE
OP ::= (OP_PLUS | OP_MINUS | OP_TIMES | OP_DIV | OP_LT | OP_LE | OP_GT | OP_GE)
RETURN_TYPE ::= (VOID | PRIMITIVE | ID)
BLOCK_STATEMENT ::= LEFT_BRACE STATEMENT* RIGHT_BRACE
RETURN_STATEMENT ::= RETURN EXP END_LINE
ARG ::= ((PRIMITIVE | ID) ID)
FOR_STATEMENT ::= FOR LEFT_PARENTHESIS EXP? END_LINE EXP? END_LINE EXP? RIGHT_PARENTHESIS (BLOCK_STATEMENT | STATEMENT)
STATEMENT ::= ((VAR_DEFINITION_EXP END_LINE) | (VAR_DEFINITION_ASSIGN_EXP END_LINE) | (VAR_ASSIGN_EXP END_LINE) | (VAR_CHANGE_ASSIGN_EXP END_LINE) | BLOCK_STATEMENT | (EXP END_LINE) | RETURN_STATEMENT | FOR_STATEMENT)
FUNCTION_DEFINITION ::= (RETURN_TYPE ID LEFT_PARENTHESIS (ARG (COMMA?))* RIGHT_PARENTHESIS LEFT_BRACE (STATEMENT*) RIGHT_BRACE)





/*
ONE_EXPRESSION ::= NUMBER
        | CALL_METHOD_EXP
        | VAR_DEFINITION_ASSIGN_EXP
        | UNARY_EXP
        | VAR_ASSIGN_EXP
        | ID
        | GROUP_EXPRESSION
        | NOT_EXP
 */

//OP_EXPRESSION ::= (ONE_EXPRESSION OP ONE_EXPRESSION)
//EXP ::= (OP_EXPRESSION | ONE_EXPRESSION)
EXP ::= (TERM_EXP ((OP_PLUS | OP_MINUS | OP_GT|OP_GE|OP_LT|OP_LE) TERM_EXP)*)

//GROUP_EXPRESSION ::= LEFT_PARENTHESIS EXP RIGHT_PARENTHESIS
//NOT_EXP ::= NOT ONE_EXPRESSION
VAR_DEFINITION_ASSIGN_EXP ::= ((PRIMITIVE | ID) ID ASSIGN EXP)
CALL_METHOD_EXP ::= (ID | CONVER_PRIMITIVE) LEFT_PARENTHESIS (EXP COMMA?)* RIGHT_PARENTHESIS
VAR_ASSIGN_EXP ::= (ID ASSIGN EXP)
VAR_CHANGE_ASSIGN_EXP ::= (ID ASSIGN_OP EXP)
POSTFIX_UNARY_EXP ::= ID (UNARY_PLUS | UNARY_MINUS)
PREFIX_UNARY_EXP ::= (UNARY_PLUS | UNARY_MINUS) ID

TERM_EXP ::= FACTOR_EXP ((OP_TIMES | OP_DIV | DOT) FACTOR_EXP)*


FACTOR_EXP ::= PRIMARY_EXP
       | ((OP_PLUS | OP_MINUS | OP_GT | OP_GE | OP_LT | OP_LE) FACTOR_EXP)
SUBJECT ::= ID (LEFT_INDEX EXP RIGHT_INDEX)*
PRIMARY_EXP ::= CALL_METHOD_EXP
       | POSTFIX_UNARY_EXP
       | PREFIX_UNARY_EXP
       | VAR_DEFINITION_ASSIGN_EXP
       | VAR_ASSIGN_EXP
       | VAR_CHANGE_ASSIGN_EXP
       | SUBJECT
       | NUMBER
       | (LEFT_PARENTHESIS EXP RIGHT_PARENTHESIS)