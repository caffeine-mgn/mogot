{
  parserClass="pw.binom.glsl.GLSLParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="GLSL"
  psiImplClassSuffix="Impl"
  psiPackage="pw.binom.glsl.psi"
  psiImplPackage="pw.binom.glsl.psi.impl"

  elementTypeHolderClass="pw.binom.glsl.psi.GLSLTypes"
  elementTypeClass="pw.binom.glsl.psi.GLSLElementType"
  tokenTypeClass="pw.binom.glsl.psi.GLSLTokenType"
}

simpleFile ::= item_*
private item_ ::= STRUCT_DEFINITION
        |FUNCTION_DEFINITION
        |GLOBAL_VAR_DEF
        |DERECTIVE
        |ANN_VERTEX
        |ANN_NORMAL
        |ANN_UV
        |ANN_PROJECTION
        |ANN_MODEL
        |PROPERTY
        |COMMENT_LINE
        |COMMENT_BLOCK
        |CRLF

STRING
private END_LINE
private SPACE
private ASSIGN
private OP_PLUS
private OP_MINUS
private OP_TIMES
private OP_DIV

private OP_AND
private OP_OR
TRUE
FALSE
DERECTIVE


private ASSIGN_PLUS
private ASSIGN_MINUS
private ASSIGN_TIMES
private ASSIGN_DIV

private OP_LT
private OP_GT
private OP_LE
private OP_GE
private LEFT_PARENTHESIS
private RIGHT_PARENTHESIS
private COMMA
private NOT
FOR
UNARY_PLUS
UNARY_MINUS
LEFT_INDEX
RIGHT_INDEX
DOT
PROPERTY ::= ANN_PROPERTY (LEFT_PARENTHESIS (ID ASSIGN EXP (COMMA)?)* RIGHT_PARENTHESIS)?
ASSIGN_OP ::= (ASSIGN_PLUS | ASSIGN_MINUS | ASSIGN_TIMES | ASSIGN_DIV)
PRIMITIVE ::= VEC2 | VEC3 | VEC4 | INT | FLOAT | MAT3 | MAT4 | BOOL
VAR_DEFINITION_EXP ::= ((PRIMITIVE | ID) ID)
VAR_DEF ::= VAR_DEFINITION_EXP GLOBAL_ARRAY_DEF
GLOBAL_VAR_DEF ::= VAR_DEF END_LINE?
STRUCT_DEFINITION ::= (CLASS) (ID) (LEFT_BRACE) ( GLOBAL_VAR_DEF )* (RIGHT_BRACE) END_LINE?
GLOBAL_ARRAY_DEF ::= (LEFT_INDEX NUMBER? RIGHT_INDEX)? (LEFT_INDEX NUMBER RIGHT_INDEX)*

RETURN_TYPE ::= (VOID | PRIMITIVE | ID)
BLOCK_STATEMENT ::= LEFT_BRACE STATEMENT* RIGHT_BRACE
RETURN_STATEMENT ::= RETURN EXP? END_LINE?
ARG ::= ((PRIMITIVE | ID) ID)
FOR_STATEMENT ::= FOR LEFT_PARENTHESIS STATEMENT? END_LINE EXP? END_LINE STATEMENT? RIGHT_PARENTHESIS (BLOCK_STATEMENT | STATEMENT)
STATEMENT ::= UNIT_STATEMENT
             | BLOCK_STATEMENT
             | RETURN_STATEMENT
             | FOR_STATEMENT

UNIT_STATEMENT ::= VAR_DEFINITION_ASSIGN_EXP
                 | VAR_DEFINITION_EXP
                 | VAR_ASSIGN_EXP
                 | VAR_CHANGE_ASSIGN_EXP
                 | EXP

FUNCTION_DEFINITION ::= RETURN_TYPE ID LEFT_PARENTHESIS (ARG (COMMA?))* RIGHT_PARENTHESIS BLOCK_STATEMENT





/*
ONE_EXPRESSION ::= NUMBER
        | CALL_METHOD_EXP
        | VAR_DEFINITION_ASSIGN_EXP
        | UNARY_EXP
        | VAR_ASSIGN_EXP
        | ID
        | GROUP_EXPRESSION
        | NOT_EXP
 */

//OP_EXPRESSION ::= (ONE_EXPRESSION OP ONE_EXPRESSION)
//EXP ::= (OP_EXPRESSION | ONE_EXPRESSION)
EXP ::= (TERM_EXP ((OP_PLUS | OP_MINUS | OP_AND | OP_OR | OP_GT|OP_GE|OP_LT|OP_LE) TERM_EXP)*)

//GROUP_EXPRESSION ::= LEFT_PARENTHESIS EXP RIGHT_PARENTHESIS
//NOT_EXP ::= NOT ONE_EXPRESSION
VAR_DEFINITION_ASSIGN_EXP ::= ((PRIMITIVE | ID) ID ASSIGN EXP)
CALL_METHOD_EXP ::= (ID | PRIMITIVE) LEFT_PARENTHESIS (EXP COMMA?)* RIGHT_PARENTHESIS
VAR_ASSIGN_EXP ::= ((ID | PRIMITIVE) ASSIGN EXP) END_LINE?
VAR_CHANGE_ASSIGN_EXP ::= (ID ASSIGN_OP EXP)
POSTFIX_UNARY_EXP ::= ID (UNARY_PLUS | UNARY_MINUS)
PREFIX_UNARY_EXP ::= (UNARY_PLUS | UNARY_MINUS) ID

TERM_EXP ::= FACTOR_EXP ((OP_TIMES | OP_DIV | DOT) FACTOR_EXP)*


FACTOR_EXP ::= PRIMARY_EXP
       | ((OP_PLUS | OP_MINUS | OP_AND | OP_OR | OP_GT | OP_GE | OP_LT | OP_LE) FACTOR_EXP)
SUBJECT ::= ID (LEFT_INDEX EXP RIGHT_INDEX)*
PRIMARY_EXP ::= CALL_METHOD_EXP
       | POSTFIX_UNARY_EXP
       | PREFIX_UNARY_EXP
       | VAR_DEFINITION_ASSIGN_EXP
       | VAR_CHANGE_ASSIGN_EXP
       | SUBJECT
       | TRUE
       | FALSE
       | NUMBER
       | STRING
       | (LEFT_PARENTHESIS EXP RIGHT_PARENTHESIS)